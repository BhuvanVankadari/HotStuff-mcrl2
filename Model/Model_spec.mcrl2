sort
    % Types of messages that can be generated within the protocol
    MessageType = struct newView
                       | prepare
                       | preCommit
                       | commit
                       | decide;
    
    % Data structure for the quorum certificate
    %
    % A Quorum Certicate (QC) is a signed message and has a specific message type, corresponding view number, the node 
    % and the signature on the replicas that signed it the signature is the number of replicas that signed it
    QC = struct createQC(type: MessageType, viewNumber: Nat, node: Node, signature: Nat)
                             | NullQC;

    % Data structure for the tree of commands
    %
    % Each tree node contains a proposed command, a parent link and an ID for the node
    % parentNode contains the id of the parent
    % parent node = NullNode for the root
    Node = struct createNode(nodeID: Nat, command: Nat, parentNode: Node) | NullNode;

    % Data structure for the message
    %
    % A message has a type, a view number, a node and an additional fiels, mjustufy
    % The leader always uses mjustify to carry the QC for different phases
    % Replicas use mjustify in newView messages to carry the highest prepareQC
    Message = struct createMessage(type: MessageType, viewNumber: Nat, node: Node, mJustify: QC,
                                   partialSignature: Signature) ?isMessage
                   | NullMessage ?isNullMessage;
    
    % Data structure for the signature
    %
    % The signature is used for signing the messages and uniquely identifying the replica
    % A faulty replica controlled by an adversary cannot replicate the signature of another replica. In this case, it 
    % cannot use another replica's ID to sign the message (guaranteed by the protocol's description of the cryptographic
    % primitives it relies on).
    Signature = struct createSignature(replicaID: Pos)
                     | NullSignature;
    
    % Data structure for message queue
    %
    % When the Channel receives a broadcast, it stores the message with its sender to forward it to all replicas
    messageTuple = struct createMessageTuple(message: Message, sender: Pos);

% Constant declarations
map
    % Number of replicas
    N: Nat; 
    
    % Number of faulty replicas
    F: Nat;

    % Maximum number of views
    %
    % Restriction on the maximum number of views to avoid infinite state spaces
    NUM_VIEWS: Pos;
    
    % List of commands to be executed in order ()
    %
    % Client sends a command from the predefined list of commands. The command list should contain at least NUM_VIEWS
    % commands
    COMMAND_LIST: List(Nat);

    % List of valid message types
    %
    % List that a faulty replica uses to randomly sample from to decide on the message type
    MESSAGE_LIST: List(MessageType);

    % List of leader scheme to aid in the rotating leader scheme
    %
    % List that all replicas use to determine the next leader
    LEADER_SCHEME: List(Pos);
    
% Constant assignments
eqn
    N = 3;
    F = 1;
    NUM_VIEWS = 3;
    COMMAND_LIST = [1, 2, 3];
    MESSAGE_LIST = [newView, prepare, preCommit, commit, decide];
    % First element is unused
    LEADER_SCHEME = [1, 1, 2, 2];

% Function declarations
map
    extends: Node # Node -> Bool;
    highestQC: QC # QC -> QC;
    safeNode: Node # QC # QC -> Bool;
    matchingMessage: Message # MessageType # Nat -> Bool;
    matchingQC: QC # MessageType # Nat -> Bool;

% Parameters for the functions
var
    % Parameters associated with the extends() function
    expectedAncestor: Node;
    nodeToCheck: Node;

    % Parameters associated with the highestQC() function
    qc1: QC;
    qc2: QC;

    % Parameters associated with the safeNode() function
    qcLocked: QC;
    qcHigh: QC;

    % Parameters associated with the matchingMessage() function
    messageToCheck: Message;
    expectedMsgType: MessageType;
    expectedViewNum: Nat;

    % Parameters associated with matchingQC() function
    QCToCheck: QC;

% Function definitions 
eqn
    %%%
    % Function to check if a node extends required node
    %
    % @param expectedAncestor    the expected ancestor node
    % @param nodeToCheck         the node whose ancestor is being checked
    %
    % @return boolean value representing whether nodeToCheck extends expectedAncestor
    %
    %%%
    (nodeToCheck == NullNode || expectedAncestor == NullNode) -> extends(expectedAncestor, nodeToCheck) = false;
    (parentNode(nodeToCheck) == NullNode) -> extends(expectedAncestor, nodeToCheck) = false;
    (nodeID(parentNode(nodeToCheck)) == nodeID(expectedAncestor)) -> extends(expectedAncestor, nodeToCheck) = true;
    ((parentNode(nodeToCheck) != NullNode) && (nodeID(parentNode(nodeToCheck)) != nodeID(expectedAncestor))) ->
    extends(expectedAncestor, nodeToCheck) = extends(expectedAncestor, parentNode(nodeToCheck));

    %%%
    % Function to retrieve the quorum certificate associated with the highest view number between two quorum 
    % certificates
    %
    % @param qc1                 the first quorum certificate being compared
    % @param qc2                 the second quorum certificate being compared
    %
    % @return the quorum certificate associated with the highest view number
    %
    %%%
    % when one QC is null, the other(non-null) QC is selected, when both are null the highest QC is null (nullQC)
    highestQC(NullQC, qc2) = qc2;
    highestQC(qc1, NullQC) = qc1;
    highestQC(NullQC, NullQC) = NullQC;
    max(viewNumber(qc1), viewNumber(qc2)) == viewNumber(qc1) -> highestQC(qc1, qc2) = qc1;
    max(viewNumber(qc1), viewNumber(qc2)) == viewNumber(qc2) -> highestQC(qc1, qc2) = qc2;

    %%%
    % Function to check if the proposed node is safe i.e. the node either extends lockedQC (safety rule) or
    % highQC.viewNumber > lockedQC.viewNumber (liveness rule)
    %
    % @param nodeToCheck         the node whose safety is being checked
    % @param qcLocked            the locked quorum certificate
    % @param qcHigh              the quorum certificate with the highest view number
    %
    % @return boolean value representing whether the node is safe (as defined in function spec) or not
    %
    %%%
    (nodeToCheck == NullNode || qcLocked == NullQC || qcHigh == NullQC) ->
        safeNode(nodeToCheck, qcLocked, qcHigh) = false;
    safeNode(nodeToCheck, qcLocked, qcHigh) =
        extends(nodeToCheck, node(qcLocked)) || (viewNumber(qcHigh) > viewNumber(qcLocked));
    
    %%%
    % Function to check if the message matches the required type and view number
    %                                                                                                                  
    % @param messageToCheck      the message that needs to be checked
    % @param expectedMsgType     the expected type of the message
    % @param expectedViewNum     the expected view number of the message
    %
    % @return boolean value representing whether the message matches the details
    %
    %%%
    (messageToCheck == NullMessage) -> matchingMessage(messageToCheck, expectedMsgType, expectedViewNum) = false;
    matchingMessage(messageToCheck, expectedMsgType, expectedViewNum) =
        (expectedMsgType == type(messageToCheck)) && (expectedViewNum == viewNumber(messageToCheck));

    %%%
    % Function to check if the QC matches the required type and view
    %                                                                                                                  
    % @param QCToCheck           the QC that needs to be checked
    % @param expectedMsgType     the expected message type of the QC
    % @param expectedViewNum     the expected view number of the QC
    %
    % @return boolean value representing whether the QC matches the details
    %
    %%%
    (QCToCheck == NullQC) -> matchingQC(QCToCheck, expectedMsgType, expectedViewNum) = false;
    matchingQC(QCToCheck, expectedMsgType, expectedViewNum) =
        (expectedMsgType == type(QCToCheck)) &&
        (expectedViewNum == viewNumber(QCToCheck));

act
    % Action to use while testing
    test;

    % Actions for sending a message. The data assciated with each action is: the message, the sender, the receiver
    send_message, receive_message_to_forward, message_sent, forward_message, receive_message, message_received, 
    forward_broadcast, receive_broadcast, broadcast_received: Message # Pos # Pos;

    % Actions for sending a broadcast. The data associated with each action is: the message, the sender
    send_broadcast, receive_broadcast_to_forward, broadcast_sent: Message # Pos;

    % Actions for leader status
    sendLeaderStatus, receiveLeaderStatus, shareLeaderStatus: Bool # Pos # Nat;

    % Actions associated with timeout in the prepare phase
    timeout_replica_prepare, timeout_leader_prepare, timeout_prepare: Nat;

    % Actions associated with timeout in the preCommit phase
    timeout_replica_preCommit, timeout_leader_preCommit, timeout_preCommit: Nat;

    % Actions associated with timeout in the commit phase
    timeout_replica_commit, timeout_leader_commit, timeout_commit: Nat;

    % Actions associated with timeout in the decide phase
    timeout_replica_decide, timeout_leader_decide, timeout_decide: Nat;

proc
    %%%%
    % Process to serve as a channel
    %
    % @param messageQueue        queue of messages to be broadasted, contains the message and the corresponding sender
    % @param broadcastCount      the ID of the next replica to broadcast to. After a broadcast is finished, this counter
    %                            is reset to 1.
    %
    %%%%
    Channel(messageQueue: List(messageTuple), broadcastCount: Pos) =
        sum receivedMessage: Message. sum s, r: Pos . (r <= N && s <= N) ->
            (
                receive_message_to_forward(receivedMessage, s, r) . 
                forward_message(receivedMessage, s, r) .
                Channel(messageQueue, broadcastCount)
            )
        +
        sum receivedMessage: Message. sum s: Pos . (s <= N) ->
            (
                receive_broadcast_to_forward(receivedMessage, s) .
                Channel(messageQueue <| createMessageTuple(receivedMessage, s), broadcastCount)
            )
        +
        (broadcastCount < N && #messageQueue > 0) ->
            (
                forward_broadcast(message(head(messageQueue)), sender(head(messageQueue)), broadcastCount) . 
                Channel(messageQueue, broadcastCount + 1)
            )
        +
        (broadcastCount == N && #messageQueue > 0) ->
            (
                forward_broadcast(message(head(messageQueue)), sender(head(messageQueue)), broadcastCount) . 
                Channel(tail(messageQueue), 1)
            );

    %%%%
    % Process for initialising the non-faulty replicas
    %
    % @param id                  the ID of the replica
    % @param currentView         the view of the protocol in which the replica is in
    % @param lockedQC            most recent signed QC that the replica received 
    %                            initially it constains the QC for view 0 and root node (0, 0, NullNode)
    % @param prepareQC           most recent prepareQC (voted in the prepare phase by at least n-f replicas)    
    %%%%
    ReplicaNewView(id: Pos, currentView: Nat, lockedQC: QC, prepareQC: QC) = 
        % A replica informs the corresponding leader process about its status (leader or not for a view)
        sendLeaderStatus(LEADER_SCHEME.(currentView + 1) == id, id, currentView + 1).
        % A newView message from view 0 is assumed when the protocol is initiated
        send_message(createMessage(newView, currentView, NullNode, prepareQC, NullSignature), id, 
                     LEADER_SCHEME.(currentView + 1)) .  
        ReplicaPrepare(id, currentView + 1, lockedQC, prepareQC);

    %%%%
    % Process for initialising the faulty replicas
    %
    % @param id                  the ID of the replica
    % @param currentView         the view of the protocol in which the replica is in
    % @param lockedQC            most recent signed QC that the replica received 
    %                            initially it constains the QC for view 0 and root node (0, 0, NullNode)
    % @param prepareQC           most recent prepareQC (voted in the prepare phase by at least n-f replicas)      
    %%%%
    FaultyReplicaNewView(id: Pos, currentView: Nat, lockedQC: QC, prepareQC: QC) = 
        % A replica informs the corresponding leader process about its status (leader or not for a view)
        sendLeaderStatus(LEADER_SCHEME.(currentView + 1) == id, id, currentView + 1).
        % A newView message from view 0 is assumed when the protocol is initiated
        send_message(createMessage(newView, currentView, NullNode, prepareQC, NullSignature), id,
        LEADER_SCHEME.(currentView + 1)) . FaultyReplicaPrepare(id, currentView + 1, lockedQC, prepareQC) 
        +
        % In this control sequence, the replica can send any type of message, with any view. This block is commented out
        % due to the state space explosion that accompanies it.
        % sum randomIndexFromMessageType: Nat . sum randomViewNumber: Nat .
        % (randomViewNumber <= NUM_VIEWS && randomIndexFromMessageType <= 4) ->
        %     send_message(createMessage(MESSAGE_LIST . randomViewNumber, randomViewNumber, NullNode, prepareQC,
        %                  NullSignature), id, LEADER_SCHEME.(currentView + 1)) . 
        %     FaultyReplicaPrepare(id, currentView + 1, lockedQC, prepareQC) 
        % +
        % Customise the specific false message, craft it with custom parameters
        send_message(createMessage(prepare, currentView, NullNode, prepareQC, NullSignature), id,
        LEADER_SCHEME.(currentView + 1)) . FaultyReplicaPrepare(id, currentView + 1, lockedQC, prepareQC) 
        +
        % Faulty replica not sending the message
        FaultyReplicaPrepare(id, currentView + 1, lockedQC, prepareQC);

    %%%%
    % Process for the prepare phase of the non-faulty replicas
    %
    % @param id                  the ID of the replica
    % @param currentView         the view of the protocol in which the replica is in
    % @param lockedQC            most recent signed QC that the replica received 
    % @param prepareQC           most recent prepareQC (voted in the prepare phase by at least n-f replicas)     
    %%%%
    ReplicaPrepare(id: Pos, currentView: Pos, lockedQC: QC, prepareQC: QC) = 
        sum receivedMessage: Message . 
        receive_broadcast(receivedMessage, LEADER_SCHEME.(currentView), id) .
            % Check validity of message
            (matchingMessage(receivedMessage, prepare, currentView) && 
            % Check validity of node 
            extends(node(mJustify(receivedMessage)), node(receivedMessage)) && 
                safeNode(node(receivedMessage), lockedQC, mJustify(receivedMessage))) ->
                    send_message(createMessage(prepare, currentView, node(receivedMessage), NullQC,
                                 createSignature(id)), id, LEADER_SCHEME.(currentView)) . delta
                    % ReplicaPreCommit(id, currentView, lockedQC, prepareQC, LEADER_SCHEME.(currentView));
    % TO DO: wait for timeout
        + timeout_replica_prepare(currentView) . delta;

    %%%%
    % Process for the prepare phase of the faulty replicas
    %
    % @param id                  the ID of the replica
    % @param currentView         the view of the protocol in which the replica is in
    % @param lockedQC            most recent signed QC that the replica received 
    % @param prepareQC           most recent prepareQC (voted in the prepare phase by at least n-f replicas)     
    %%%%
    FaultyReplicaPrepare(id: Pos, currentView: Pos, lockedQC: QC, prepareQC: QC) = 
        sum receivedMessage: Message . 
        receive_broadcast(receivedMessage, LEADER_SCHEME.(currentView), id) .
        (
            % Check validity of message
            (matchingMessage(receivedMessage, prepare, currentView) && 
            % Check validity of node 
            extends(node(mJustify(receivedMessage)), node(receivedMessage)) && 
                safeNode(node(receivedMessage), lockedQC, mJustify(receivedMessage))) ->
                    send_message(createMessage(prepare, currentView, node(receivedMessage), NullQC,
                                 createSignature(id)), id, LEADER_SCHEME.(currentView)) . delta
                    + delta
                    % ReplicaPreCommit(id, currentView, lockedQC, prepareQC, LEADER_SCHEME.(currentView));
        )
        +
        timeout_replica_prepare(currentView) . delta;
    % TO DO: wait for timeout

    %%%%
    % Process for the initializing the leader 
    %
    % @param id                  the ID of the replica that has a leader role in the current view
    % @param currentView         the view of the protocol in which the replica is in
    % @param highQC              the highest prepareQC received from replicas
    % @param counterCommand      index that keeps track of the next command that needs to be executed 
    %                            and of the next nodeID
    %
    %%%%
    LeaderNewView(id : Pos, currentView: Nat, highQC: QC, counterCommand: Nat) =
        sum receivedLeaderStatus: Bool, receivedView: Nat .
        receiveLeaderStatus(receivedLeaderStatus, id, receivedView) .
        LeaderPrepare(id, receivedView, [], highQC, counterCommand, receivedLeaderStatus);

    %%%%
    % Process for the initializing the faulty leader 
    %
    % @param id                  the ID of the replica that has a leader role in the current view
    % @param currentView         the view of the protocol in which the replica is in
    % @param highQC              the highest prepareQC received from replicas
    % @param counterCommand      index that keeps track of the next command that needs to be executed 
    %                            and of the next nodeID
    %
    %%%%
    FaultyLeaderNewView(id : Pos, currentView: Nat, highQC: QC, counterCommand: Nat) =
        sum receivedLeaderStatus: Bool, receivedView: Nat .
        receiveLeaderStatus(receivedLeaderStatus, id, receivedView) .
        FaultyLeaderPrepare(id, receivedView, [], highQC, counterCommand, receivedLeaderStatus);

    %%%%
    % Process for the leader in the prepare phase
    %
    % @param id                  the ID of the replica that has a leader role in the current view
    % @param currentView         the view of the protocol in which the replica is in
    % @param receivedMsgFrom     list of replicas that sent a newView message to the leader
    % @param highQC              the highest prepareQC received from replicas
    % @param counterCommand      index that keeps track of the next command that needs to be executed 
    %                            and of the next nodeID
    % @param isLeader            a boolean value indicating whether the replica is a leader depending on the view
    %
    %%%%
    LeaderPrepare(id : Pos, currentView: Nat, receivedMsgFrom: List(Pos), highQC: QC, counterCommand: Nat, 
                  isLeader: Bool) =
        sum receivedMessage: Message . sum s: Pos .
        (
            (s <= N) ->
            (
                receive_message(receivedMessage, s, id) .
                (isLeader) ->
                (
                    % It is an invalid message
                    (!(s <= N && matchingMessage(receivedMessage, newView, Int2Nat(currentView - 1)))) ->
                        LeaderPrepare(id, currentView, receivedMsgFrom, highQC, counterCommand, isLeader) 
                    <>
                    % Leader did not receive enough newView messages, it waits for more messages
                    (
                        (#receivedMsgFrom < N - F) -> 
                            (
                                LeaderPrepare(id, currentView, receivedMsgFrom <| s, highestQC(highQC,
                                            mJustify(receivedMessage)), counterCommand, isLeader)
                            )   
                    )
                )
                <>
                % Replica is not the leader 
                LeaderPrepare(id, currentView, receivedMsgFrom, highQC, counterCommand, isLeader)
            )
        )
        +
        (
            % Leader received N - F correct newView messages, it can move to the next phase 
            (isLeader && #receivedMsgFrom == N - F) ->
            (
                send_broadcast(createMessage(prepare, currentView, createNode(counterCommand, 
                COMMAND_LIST.counterCommand, node(highQC)), highQC, NullSignature), id) .
                % LeaderPreCommit(id, currentView, [], highQC, counterCommand + 1, isLeader)
                timeout_leader_prepare(currentView) . delta
            )
        );

    %%%%
    % Process for the faulty leader in the prepare phase
    %
    % @param id                  the ID of the replica that has a leader role in the current view
    % @param currentView         the view of the protocol in which the replica is in
    % @param receivedMsgFrom     list of replicas that sent a newView message to the leader
    % @param highQC              the highest prepareQC received from replicas
    % @param counterCommand      index that keeps track of the next command that needs to be executed 
    %                            and of the next nodeID
    % @param isLeader            a boolean value indicating whether the replica is a leader depending on the view
    %
    %%%%
    FaultyLeaderPrepare(id : Pos, currentView: Nat, receivedMsgFrom: List(Pos), highQC: QC, counterCommand: Nat, 
                  isLeader: Bool) =
        sum receivedMessage: Message . sum s: Pos .
        (
            (s <= N) ->
            (
                receive_message(receivedMessage, s, id) .
                (isLeader) ->
                (
                    % It is an invalid message
                    (!(s <= N && matchingMessage(receivedMessage, newView, Int2Nat(currentView - 1)))) ->
                        LeaderPrepare(id, currentView, receivedMsgFrom, highQC, counterCommand, isLeader) 
                    <>
                    % Leader did not receive enough newView messages, it waits for more messages
                    (
                        (#receivedMsgFrom < N - F && !(s in receivedMsgFrom)) -> 
                            (
                                LeaderPrepare(id, currentView, receivedMsgFrom <| s, highestQC(highQC,
                                              mJustify(receivedMessage)), counterCommand, isLeader)
                            )   
                    )
                )
                <>
                % Replica is not the leader 
                LeaderPrepare(id, currentView, receivedMsgFrom, highQC, counterCommand, isLeader)
            )
        )
        +
        (
            % Leader received N - F correct newView messages, it can move to the next phase 
            (isLeader && #receivedMsgFrom == N - F) ->               
            (
                send_broadcast(createMessage(prepare, currentView, createNode(counterCommand, 
                COMMAND_LIST.counterCommand, node(highQC)), highQC, NullSignature), id) .
                % LeaderPreCommit(id, currentView, [], highQC, counterCommand + 1, isLeader)
                delta
                +
                % Faulty leader does not send broadcast
                delta
            )
        );

    %%%%
    % Process for the leader in the pre-commit phase
    %
    % @param id                  the ID of the replica that has a leader role in the current view
    % @param currentView         the view of the protocol in which the replica is in
    % @param receivedVoteFrom     list of replicas that sent a newView message to the leader
    % @param highQC              the highest prepareQC received from replicas
    % @param counterCommand      index that keeps track of the next command that needs to be executed 
    %                            and of the next nodeID
    % @param isLeader            a boolean value indicating whether the replica is a leader depending on the view
    %
    %%%%
    LeaderPreCommit(id : Pos, currentView: Nat, receivedVoteFrom: List(Pos), highQC: QC, counterCommand: Nat, 
                  isLeader: Bool) =
        sum vote: Message . sum s: Pos .
        (
            (s <= N) ->
            (
                receive_message
            )
        )
        
        
init 
    % hide({shareLeaderStatus},
        allow({message_sent, message_received, broadcast_sent, broadcast_received, shareLeaderStatus, test, 
               timeout_prepare},
            comm({
                send_message | receive_message_to_forward -> message_sent,
                forward_message | receive_message -> message_received,
                send_broadcast | receive_broadcast_to_forward -> broadcast_sent,
                forward_broadcast | receive_broadcast -> broadcast_received,
                sendLeaderStatus | receiveLeaderStatus -> shareLeaderStatus,
                timeout_replica_prepare | timeout_replica_prepare | timeout_replica_prepare | timeout_replica_prepare |
                timeout_leader_prepare -> timeout_prepare
                },
                    ReplicaNewView(1, 0, createQC(newView, 0, createNode(0, 0, NullNode), N),  createQC(newView, 0, 
                    createNode(0, 0, NullNode), N))||
                    ReplicaNewView(2, 0, createQC(newView, 0, createNode(0, 0, NullNode), N),  createQC(newView, 0,
                    createNode(0, 0, NullNode), N)) ||
                    ReplicaNewView(3, 0, createQC(newView, 0, createNode(0, 0, NullNode), N),  createQC(newView, 0,
                    createNode(0, 0, NullNode), N)) ||
                    FaultyReplicaNewView(4, 0, createQC(newView, 0, createNode(0, 0, NullNode), N),  createQC(newView, 0,
                    createNode(0, 0, NullNode), N)) ||
                    LeaderNewView(1, 1, NullQC, 0) ||
                    LeaderNewView(2, 1, NullQC, 0) ||
                    LeaderNewView(3, 1, NullQC, 0) ||
                    FaultyLeaderNewView(4, 1, NullQC, 0) ||
                    Channel([], 1)
	 ));
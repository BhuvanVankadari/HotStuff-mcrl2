sort
    % Types of messages that can be generated within the protocol
    MessageType = struct newView
                       | prepare
                       | preCommit
                       | commit
                       | decide;
    
    % Data structure for the quorum certificate
    %
    % A Quorum Certicate (QC) is a signed message and has a specific message type, corresponding view number, the node 
    % and the signature on the replicas that signed it the signature is the number of replicas that signed it
    QC = struct createQC(type: MessageType, viewNumber: Nat, node: Node, signature: Nat)
                             | NullQC;

    % Data structure for the tree of commands
    %
    % Each tree node contains a proposed command, a parent link and an ID for the node
    % parentLink contains the id of the parent
    % parent link = 0 for the root
    Node = struct createNode(nodeID: Nat, command: Nat, parentLink: Nat) | NullNode;

    % Data structure for the message
    %
    % A message has a type, a view number, a node and an additional fiels, mjustufy
    % The leader always uses mjustify to carry the QC for different phases
    % Replicas use mjustify in newView messages to carry the highest prepareQC
    Message = struct createMessage(type: MessageType, viewNumber: Nat, node: Node, mJustify: QC,
                                   partialSignature: Signature) ?isMessage
                   | NullMessage ?isNullMessage;
    
    % Data structure for the signature
    %
    % The signature is used for signing the messages and uniquely identifying the replica
    % A faulty replica controlled by an adversary cannot replicate the signature of another replica. In this case, it 
    % cannot use another replica's ID to sign the message (guaranteed by the protocol's description of the cryptographic
    % primitives it relies on).
    Signature = struct createSignature(replicaID: Pos)
                     | NullSignature;
                     
% Constant declarations
map
    % Number of replicas
    N: Nat; 
    
    % Number of faulty replicas
    F: Nat;

    % Maximum number of views
    %
    % Restriction on the maximum number of views to avoid infinite state spaces
    NUM_VIEWS: Pos;
    
    % List of commands to be executed in order ()
    %
    % Client sends a command between 0 and MAX_COMMAND to avoid infinite state spaces
    COMMAND_LIST: List(Nat);

    % List of valid message types
    %
    % List that a faulty replica uses to randomly sample from to decide on the message type
    MESSAGE_LIST: List(Message_type);
    
% Constant assignments
eqn
    N = 3;
    F = 1;
    NUM_VIEWS = 3;
    MAX_COMMAND = 3;
    MESSAGE_LIST = [newView, prepare, preCommit, commit, decide];

% Function declarations
map
    extends: Node # Node -> Bool;
    highestQC: QC # QC -> QC;
    safeNode: Node # QC # QC -> Bool;
    matchingMessage: Message # MessageType # Nat -> Bool;
    matchingQC: QC # MessageType # Nat -> Bool;

% Parameters for the functions
var
    % Parameters associated with the extends() function
    expectedParent: Node;
    nodeToCheck: Node;

    % Parameters associated with the highestQC() function
    qc1: QC;
    qc2: QC;

    % Parameters associated with the safeNode() function
    nodeToCheck: Node;
    qcLocked: QC;
    qcHigh: QC;

    % Parameters associated with the matchingMessage() function
    messageToCheck: Message;
    expectedMsgType: MessageType;
    expectedViewNum: Nat;

    % Parameters associated with matchingQC() function
    QCToCheck: QC;
    expectedMsgType: MessageType;
    expectedViewNum: Nat;

% Function definitions 
eqn
    %%%
    % Function to check if a node extends required node
    %
    % @param expectedParent      the expected parent node
    % @param nodeToCheck         the node whose parent is being checked
    %
    % @return boolean value representing whether nodeToCheck extends expectedParent
    %
    %%%
    extends(expectedParent, nodeToCheck) = parentLink(nodeToCheck) == nodeID(expectedParent);
    (expectedParent == nullNode || nodeToCheck == nullNode) -> extends(expectedParent, nodeToCheck) = false;

    %%%
    % Function to retrieve the quorum certificate associated with the highest view number between two quorum 
    % certificates
    %
    % @param qc1                 the first quorum certificate being compared
    % @param qc2                 the second quorum certificate being compared
    %
    % @return the quorum certificate associated with the highest view number
    %
    %%%
    % when one QC is null, the other(non-null) QC is selected, when both are null the highest QC is null (nullQC)
    highestQC(NullQC, qc2) = qc2;
    highestQC(qc1, NullQC) = qc1;
    highestQC(NullQC, NullQC) = NullQC;
    max(viewNumber(qc1), viewNumber(qc2)) == viewNumber(qc1) -> highestQC(qc1, qc2) = qc1;
    max(viewNumber(qc1), viewNumber(qc2)) == viewNumber(qc2) -> highestQC(qc1, qc2) = qc2;

    %%%
    % Function to check if the proposed node is safe i.e. the node either extends lockedQC (safety rule) or
    % highQC.viewNumber > lockedQC.viewNumber (liveness rule)
    %
    % @param nodeToCheck         the node whose safety is being checked
    % @param qcLocked            the locked quorum certificate
    % @param qcHigh              the quorum certificate with the highest view number
    %
    % @return boolean value representing whether the node is safe (as defined in function spec) or not
    %
    %%%
    (nodeToCheck == nullNode || qcLocked == nullQC || qcHigh == nullQC) ->
        safeNode(nodeToCheck, qcLocked, qcHigh) = false;
    safeNode(nodeToCheck, qcLocked, qcHigh) =
        extends(nodeToCheck, node(qcLocked)) || (viewNumber(qcHigh) > viewNumber(qcLocked));
    
    %%%
    % Function to check if the message matches the required type and view number
    %                                                                                                                  
    % @param messageToCheck      the message that needs to be checked
    % @param expectedMsgType     the expected type of the message
    % @param expectedViewNum     the expected view number of the message
    %
    % @return boolean value representing whether the message matches the details
    %
    %%%
    (messageToCheck == NullMessage) -> matchingMessage(messageToCheck, expectedMsgType, expectedViewNum) = false;
    matchingMessage(messageToCheck, expectedMsgType, expectedViewNum) =
        (expectedMsgType == type(messageToCheck)) && (expectedViewNum == viewNumber(messageToCheck));

    %%%
    % Function to check if the QC matches the required type and view
    %                                                                                                                  
    % @param QCToCheck           the QC that needs to be checked
    % @param expectedMsgType     the expected message type of the QC
    % @param expectedViewNum     the expected view number of the QC
    %
    % @return boolean value representing whether the QC matches the details
    %
    %%%
    (QCToCheck == NullQC) -> matchingQC(QCToCheck, expectedMsgType, expectedViewNum) = false;
    matchingQC(QCToCheck, expectedMsgType, expectedViewNum) =
        (expectedMsgType == type(QCToCheck)) &&
        (expectedViewNum == viewNumber(QCToCheck));

act
    % Actions for sending a message. The data assciated with each action is: the message, the sender, the receiver
    send_message, receive_message_to_forward, message_sent, forward_message, receive_message, message_received, 
    send_broadcast, receive_broadcast_to_forward, broadcast_sent, forward_broadcast, receive_broadcast, 
    broadcast_received: Message # Pos # Pos;

%%%%
% Process for initialising the non-faulty replicas
%
% @param id                  the ID of the replica
% @param currentView         the view of the protocol in which the replica is in
% @param lockedQC            most recent signed QC that the replica received 
%                            initially it constains the QC for view 0 and root node (1, 0, 0)
% @param prepareQC           most recent prepareQC (voted in the prepare phase by at least n-f replicas)    
% @param currentLeader       leader of the current view    
%%%%
proc ReplicaNewView(id: Pos, currentView: Pos, lockedQC: QC, prepareQC: QC, currentLeader: Pos) = 
    % A newView message from view 0 is assumed when the protocol is initiated
    send_message(createMessage(newView, currentView, nullNode, prepareQC), id, currentLeader) . 
    ReplicaPrepare(id, currentView + 1, lockedQC, prepareQC, currentLeader);

%%%%
% Process for the prepare phase of the non-faulty replicas
%
% @param id                  the ID of the replica
% @param currentView         the view of the protocol in which the replica is in
% @param lockedQC            most recent signed QC that the replica received 
% @param prepareQC           most recent prepareQC (voted in the prepare phase by at least n-f replicas)    
% @param currentLeader       leader of the current view    
%%%%
proc ReplicaPrepare(id: Pos, currentView: Pos, lockedQC: QC, prepareQC: QC, currentLeader: Pos ) = 
    sum message: Message -> receive_broadcast(message, currentLeader, id).
                            % Check validity of message
                            (matchingMessage(message, prepare, currentView) && 
                             extends)

%%%%
% Process for the initializing the leader 
%
% @param id                  the ID of the replica that has a leader role in the current view
% @param currentView         the view of the protocol in which the replica is in
% @param receivedMsgFrom     list of replicas that sent a newView message to the leader
% @
% @param prepareQC           most recent prepareQC (voted in the prepare phase by at least n-f replicas)    
% @param currentLeader       leader of the current view    
%%%%
proc LeaderInitial(id : Pos, currentView: Nat, receivedMsgFrom: List(Pos), proposedNode: Node, highQC: QC, commandList: List(Nat), 
				   nextIdNode: Nat) = 
	% leader collects the commands from clients and adds them to the command list
	sum new_command: Nat. (new_command <= max_command) -> get_command_from_client(new_command, id).LeaderInitial(id, currentView,
														numOfMessagesPerView, proposedNode, highQC, commandList <| new_command, 
														nextIdNode) + 
	
	% Prepare phase 
	% wait for n-f  new view messages for view 0 - special messages to start the protocol
	% check if the message is of the expected type
	% every view, leader gets a command from the client this becomes the leaf of the highest qc node and it is proposed to replicas
	% highest QC is the QC with the highest view number from all prepareQC's from replicas

	(count(Int2Nat(currentView - 1), numOfMessagesPerView ) < n - f) ->
							(sum i: Message.(isMessage(i)) -> sum sender: Pos. (sender <= n) -> receive_message(i,sender,id).
							((MatchingMessage(i, newView, Int2Nat(currentView - 1)) == true) -> (LeaderInitial(id,currentView, 
																								numOfMessagesPerView + Set2Bag({viewNum(i)}),
																								proposedNode, highestQC(highQC, mjustify(i)), 
																								commandList, nextIdNode))

																							% if message is not of expected type or 
																							% view number ignore it 
																							<> 	LeaderInitial(id, currentView,
																								numOfMessagesPerView, proposedNode, highQC,
																								commandList, nextIdNode))) + 

	% once n-f messages are collected and there is a command to send, the leader broadcasts the proposal (new node) to all replicas
	% create a node with the first command in the command list, the next node ID and the parent link - the node id of highQC
	% the command is then deleted from commandList and nextIdNode is incremented and the created node becomes the proposedNode

	(count(Int2Nat(currentView - 1), numOfMessagesPerView ) >= n - f && #commandList > 0) -> (send_broadcast(message(prepare,currentView,
																							node(nextIdNode,  head(commandList), 
																							nodeID(node(highQC))), highQC), id).
																							LeaderPreCommit(id,currentView, 
																							node(nextIdNode, head(commandList), 
																							nodeID(node(highQC))), highQC, [],
																							tail(commandList), Int2Nat(nextIdNode + 1))
																							);

proc Client()                                                                 